#!/usr/bin/env python3

import argparse
import json
import os
import plistlib
import re
import sys
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
import subprocess


CONFIG_DIR = Path.home() / ".config" / "jd"
CONFIG_PATH = CONFIG_DIR / "settings.json"


@dataclass
class ProjectConfig:
    key: str
    path: Path


def load_settings() -> Dict[str, Any]:
    if not CONFIG_PATH.exists():
        return {"projects": {}, "default_project": None}
    try:
        with CONFIG_PATH.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {"projects": {}, "default_project": None}


def save_settings(settings: Dict[str, Any]) -> None:
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with CONFIG_PATH.open("w", encoding="utf-8") as f:
        json.dump(settings, f, indent=2)


def resolve_project_config(project_key: Optional[str]) -> ProjectConfig:
    settings = load_settings()
    projects = settings.get("projects", {})
    default_key = settings.get("default_project")

    key = project_key or default_key
    if not key:
        print(
            "No default project configured. Set one with: jd config set-project <KEY> <PATH> && jd config set-default <KEY>",
            file=sys.stderr,
        )
        sys.exit(2)

    path_str = projects.get(key)
    if not path_str:
        print(f"Project '{key}' not found in settings. Add it with: jd config set-project {key} /absolute/path", file=sys.stderr)
        sys.exit(2)

    project_path = Path(path_str).expanduser().resolve()
    if not project_path.exists() or not project_path.is_dir():
        print(f"Project path does not exist or is not a directory: {project_path}", file=sys.stderr)
        sys.exit(2)

    return ProjectConfig(key=key, path=project_path)


def convert_underscores_to_spaces(text: str) -> str:
    return text.replace("_", " ")


def parse_range_dirname(name: str) -> Optional[Tuple[str, str]]:
    # e.g., "30-39_Research_Area"
    m = re.match(r"^(\d{2}-\d{2})_(.+)$", name)
    if not m:
        return None
    jd_number = m.group(1)
    title = convert_underscores_to_spaces(m.group(2))
    return jd_number, title


def parse_category_dirname(name: str) -> Optional[Tuple[str, str]]:
    # e.g., "30_Topic_Name"
    m = re.match(r"^(\d{2})_(.+)$", name)
    if not m:
        return None
    jd_number = m.group(1)
    title = convert_underscores_to_spaces(m.group(2))
    return jd_number, title


def parse_item_name(name: str) -> Optional[Tuple[str, str, str]]:
    # Supports directories and files: "30.01_Something" or "30.01_Something.ext"
    m = re.match(r"^(\d{2}\.\d{2})_(.+?)(?:\.(.+))?$", name)
    if not m:
        return None
    jd_number = m.group(1)
    title = convert_underscores_to_spaces(m.group(2))
    extension = m.group(3) or ""
    return jd_number, title, extension.lower()


def find_notes_for_code(directory: Path, code: str) -> Optional[str]:
    # Look for ".<code>_notes" or ".<prefix>_notes" (prefix is first two digits)
    candidates = [f".{code}_notes"]
    if re.match(r"^\d{2}(?:-\d{2}|\.\d{2})?$", code):
        prefix = code.split("-")[0].split(".")[0]
        candidates.append(f".{prefix}_notes")

    for candidate in candidates:
        p = directory / candidate
        if p.exists() and p.is_file():
            try:
                return p.read_text(encoding="utf-8").strip()
            except Exception:
                return None
    return None


def parse_webloc_url(path: Path) -> Optional[str]:
    try:
        with path.open("rb") as f:
            pl = plistlib.load(f)
        url = pl.get("URL") or pl.get("URLString")
        if isinstance(url, str):
            return url
    except Exception:
        return None
    return None


def build_index(project: ProjectConfig) -> Dict[str, Any]:
    project_root = project.path

    def make_folder_item(level: str, jd_number: str, title: str, path: Path, notes: Optional[str]) -> Dict[str, Any]:
        return {
            "level": level,
            "jd_number": jd_number,
            "title": title,
            "path": str(path),
            "type": "folder",
            "notes": notes,
            "children": [],
        }

    index: Dict[str, Any] = {
        "project_key": project.key,
        "project_path": str(project_root),
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "items": [],
    }

    # First level: NN-NN_* directories
    for range_dir in sorted([p for p in project_root.iterdir() if p.is_dir()]):
        parsed_range = parse_range_dirname(range_dir.name)
        if not parsed_range:
            continue
        range_code, range_title = parsed_range
        range_notes = find_notes_for_code(range_dir, range_code)
        range_item = make_folder_item("range", range_code, range_title, range_dir, range_notes)

        # Second level: NN_*
        for category_dir in sorted([p for p in range_dir.iterdir() if p.is_dir()]):
            parsed_cat = parse_category_dirname(category_dir.name)
            if not parsed_cat:
                continue
            cat_code, cat_title = parsed_cat
            cat_notes = find_notes_for_code(category_dir, cat_code)
            cat_item = make_folder_item("category", cat_code, cat_title, category_dir, cat_notes)

            # Third level: items can be directories or files starting with NN.NN_*
            for child in sorted(list(category_dir.iterdir())):
                parsed_item = parse_item_name(child.name)
                if not parsed_item:
                    continue
                item_code, item_title, ext = parsed_item
                item_notes = find_notes_for_code(child if child.is_dir() else category_dir, item_code)

                if child.is_dir():
                    item_entry: Dict[str, Any] = {
                        "level": "item",
                        "jd_number": item_code,
                        "title": item_title,
                        "path": str(child),
                        "type": "folder",
                        "notes": item_notes,
                    }
                else:
                    if ext == "webloc":
                        url = parse_webloc_url(child)
                        item_entry = {
                            "level": "item",
                            "jd_number": item_code,
                            "title": item_title,
                            "path": str(child),
                            "type": "link",
                            "url": url,
                            "notes": item_notes,
                        }
                    else:
                        item_entry = {
                            "level": "item",
                            "jd_number": item_code,
                            "title": item_title,
                            "path": str(child),
                            "type": "file",
                            "extension": ext,
                            "notes": item_notes,
                        }

                cat_item["children"].append(item_entry)

            range_item["children"].append(cat_item)

        index["items"].append(range_item)

    return index


def write_index(project: ProjectConfig, index_data: Dict[str, Any]) -> Path:
    out_path = project.path / ".jd_index.json"
    with out_path.open("w", encoding="utf-8") as f:
        json.dump(index_data, f, indent=2)
    return out_path


def cmd_index(args: argparse.Namespace) -> int:
    project = resolve_project_config(args.project)
    index_data = build_index(project)
    out = write_index(project, index_data)
    print(f"Index written: {out}")
    return 0


def read_index_if_exists(project: ProjectConfig) -> Optional[Dict[str, Any]]:
    path = project.path / ".jd_index.json"
    if not path.exists():
        return None
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return None


def load_or_build_index(project: ProjectConfig) -> Dict[str, Any]:
    existing = read_index_if_exists(project)
    if existing is not None:
        return existing
    data = build_index(project)
    write_index(project, data)
    return data


def split_project_prefix_from_code(raw: str) -> Tuple[Optional[str], str]:
    # Accept forms like R50.30.01 or P10.30.01. Only treat a leading token as project if it starts with a letter
    m = re.match(r"^([A-Za-z][A-Za-z0-9]*)\.(.+)$", raw)
    if m:
        return m.group(1), m.group(2)
    return None, raw


def find_by_code(index_data: Dict[str, Any], code: str) -> Optional[Dict[str, Any]]:
    for range_item in index_data.get("items", []):
        if range_item.get("jd_number") == code:
            return range_item
        for cat_item in range_item.get("children", []):
            if cat_item.get("jd_number") == code:
                return cat_item
            for item in cat_item.get("children", []):
                if item.get("jd_number") == code:
                    return item
    return None


def open_with_macos(path_or_url: str) -> int:
    try:
        return subprocess.call(["open", path_or_url])
    except Exception:
        return 1


def print_file_contents(path: Path) -> int:
    try:
        # Prefer utf-8; if it fails, replace invalid chars
        text = path.read_text(encoding="utf-8", errors="replace")
        sys.stdout.write(text)
        return 0
    except Exception:
        # Fallback: open with default app
        return open_with_macos(str(path))


def shell_single_quote(s: str) -> str:
    # Safely single-quote a string for POSIX shells
    return "'" + s.replace("'", "'\"'\"'") + "'"


def applescript_cd_terminal(directory_path: str) -> bool:
    # Sends a cd command to the front window of Terminal.app
    cd_command = f"cd {shell_single_quote(directory_path)}"
    # Target the selected tab of the front window to avoid opening a new tab
    script = (
        "tell application \"Terminal\" to do script \""
        + cd_command.replace("\\", "\\\\").replace("\"", "\\\"")
        + "\" in selected tab of front window"
    )
    try:
        result = subprocess.run(["osascript", "-e", script], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return result.returncode == 0
    except Exception:
        return False


def applescript_cd_iterm(directory_path: str) -> bool:
    # Sends a cd command to the current session of the current window in iTerm2
    cd_command = f"cd {shell_single_quote(directory_path)}"
    # Try iTerm2 first, then legacy iTerm
    script_iterm2 = (
        "tell application \"iTerm2\" to tell current window to tell current session to write text \""
        + cd_command.replace("\\", "\\\\").replace("\"", "\\\"")
        + "\""
    )
    script_iterm = (
        "tell application \"iTerm\" to tell current window to tell current session to write text \""
        + cd_command.replace("\\", "\\\\").replace("\"", "\\\"")
        + "\""
    )
    try:
        res = subprocess.run(["osascript", "-e", script_iterm2], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        if res.returncode == 0:
            return True
        res = subprocess.run(["osascript", "-e", script_iterm], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return res.returncode == 0
    except Exception:
        return False


def change_directory_in_current_terminal(directory_path: str) -> bool:
    # Only works on macOS Terminal/iTerm using AppleScript
    term_program = os.environ.get("TERM_PROGRAM", "")
    if term_program == "Apple_Terminal":
        return applescript_cd_terminal(directory_path)
    # iTerm indicators
    if term_program.lower().startswith("iterm") or os.environ.get("ITERM_SESSION_ID"):
        return applescript_cd_iterm(directory_path)
    # Fallback: attempt Terminal first, then iTerm
    if applescript_cd_terminal(directory_path):
        return True
    if applescript_cd_iterm(directory_path):
        return True
    return False


def cmd_open(args: argparse.Namespace) -> int:
    # Support project prefix in code (e.g., R50.30.01). Explicit -p overrides
    proj_from_code, bare_code = split_project_prefix_from_code(args.code)
    project_key = args.project or proj_from_code
    project = resolve_project_config(project_key)

    index_data = load_or_build_index(project)
    entry = find_by_code(index_data, bare_code)
    if entry is None:
        print(f"Code not found in index for project '{project.key}': {bare_code}", file=sys.stderr)
        return 1

    entry_type = entry.get("type")
    entry_path = entry.get("path")

    if entry_type == "folder":
        return open_with_macos(entry_path)
    if entry_type == "link":
        url = entry.get("url")
        target = url if isinstance(url, str) and url else entry_path
        return open_with_macos(target)
    if entry_type == "file":
        return print_file_contents(Path(entry_path))

    # Unknown type; attempt to open as a path
    if entry_path:
        return open_with_macos(entry_path)
    print("Unknown entry type and no path to open", file=sys.stderr)
    return 1


def cmd_go(args: argparse.Namespace) -> int:
    # Default navigation behavior: folders -> print path; links -> open; files -> cat
    proj_from_code, bare_code = split_project_prefix_from_code(args.code)
    project_key = args.project or proj_from_code
    project = resolve_project_config(project_key)

    index_data = load_or_build_index(project)
    entry = find_by_code(index_data, bare_code)
    if entry is None:
        print(f"Code not found in index for project '{project.key}': {bare_code}", file=sys.stderr)
        return 1

    entry_type = entry.get("type")
    entry_path = entry.get("path")

    if entry_type == "folder":
        # Print the absolute path; external processes cannot change the parent shell cwd
        print(entry_path)
        return 0
    if entry_type == "link":
        url = entry.get("url")
        target = url if isinstance(url, str) and url else entry_path
        return open_with_macos(target)
    if entry_type == "file":
        return print_file_contents(Path(entry_path))

    if entry_path:
        print(entry_path)
        return 0
    print("Unknown entry type and no path to open", file=sys.stderr)
    return 1


def cmd_dir(args: argparse.Namespace) -> int:
    # Resolve to directory path only; return 0 if folder, else non-zero
    proj_from_code, bare_code = split_project_prefix_from_code(args.code)
    project_key = args.project or proj_from_code
    project = resolve_project_config(project_key)

    index_data = load_or_build_index(project)
    entry = find_by_code(index_data, bare_code)
    if entry is None:
        print(f"Code not found in index for project '{project.key}': {bare_code}", file=sys.stderr)
        return 2

    if entry.get("type") == "folder":
        print(entry.get("path", ""))
        return 0

    print("Not a folder", file=sys.stderr)
    return 1


def cmd_config(args: argparse.Namespace) -> int:
    settings = load_settings()

    if args.action == "set-project":
        key = args.key
        path = Path(args.path).expanduser().resolve()
        if not path.exists() or not path.is_dir():
            print(f"Not a directory: {path}", file=sys.stderr)
            return 2
        settings.setdefault("projects", {})[key] = str(path)
        save_settings(settings)
        print(f"Saved project '{key}' -> {path}")
        return 0

    if args.action == "set-default":
        key = args.key
        if key not in settings.get("projects", {}):
            print(f"Unknown project key: {key}. Add it first with: jd config set-project {key} /absolute/path", file=sys.stderr)
            return 2
        settings["default_project"] = key
        save_settings(settings)
        print(f"Default project set: {key}")
        return 0

    if args.action == "show":
        print(json.dumps(settings, indent=2))
        return 0

    print("Unknown config action", file=sys.stderr)
    return 2


def parse_args(argv: List[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(prog="jd", description="Johnny Decimal terminal tool")

    subparsers = parser.add_subparsers(dest="command")

    # index
    p_index = subparsers.add_parser("index", help="Build index for a project")
    p_index.add_argument("--project", "-p", help="Project key (e.g., R50). Defaults to configured default.")
    p_index.set_defaults(func=cmd_index)

    # config
    p_config = subparsers.add_parser("config", help="Manage configuration")
    config_sub = p_config.add_subparsers(dest="action")

    p_cfg_setproj = config_sub.add_parser("set-project", help="Map a project key to a path")
    p_cfg_setproj.add_argument("key", help="Project key (e.g., R50)")
    p_cfg_setproj.add_argument("path", help="Absolute path to project root (e.g., /Users/you/R50_Research)")
    p_cfg_setproj.set_defaults(func=cmd_config)

    p_cfg_setdef = config_sub.add_parser("set-default", help="Set the default project key")
    p_cfg_setdef.add_argument("key", help="Existing project key to set as default")
    p_cfg_setdef.set_defaults(func=cmd_config)

    p_cfg_show = config_sub.add_parser("show", help="Show current settings")
    p_cfg_show.set_defaults(func=cmd_config)

    # open
    p_open = subparsers.add_parser("open", help="Open a JD code (folder, link, or file)")
    p_open.add_argument("code", help="JD code or project-prefixed code (e.g., 30.01 or R50.30.01 or 30 or 30-39)")
    p_open.add_argument("--project", "-p", help="Project key (e.g., R50). Optional if code is prefixed or default is set.")
    p_open.set_defaults(func=cmd_open)

    # go (default behavior)
    p_go = subparsers.add_parser("go", help="Default navigation: folders -> print path, links -> open, files -> cat")
    p_go.add_argument("code", help="JD code or project-prefixed code (e.g., 30.01 or R50.30.01 or 30 or 30-39)")
    p_go.add_argument("--project", "-p", help="Project key (e.g., R50). Optional if code is prefixed or default is set.")
    p_go.set_defaults(func=cmd_go)

    # dir (folder path only)
    p_dir = subparsers.add_parser("dir", help="Print the directory path for a JD code if it is a folder")
    p_dir.add_argument("code", help="JD code or project-prefixed code (e.g., 30 or 30-39 or 30.01)")
    p_dir.add_argument("--project", "-p", help="Project key (e.g., R50). Optional if code is prefixed or default is set.")
    p_dir.set_defaults(func=cmd_dir)

    # default behavior: if no command, run index with default project
    parser.set_defaults(func=cmd_index)

    return parser.parse_args(argv)


def main(argv: Optional[List[str]] = None) -> int:
    raw_args = argv if argv is not None else sys.argv[1:]
    # Implicit "go" if first token is not a known subcommand/help flag
    known = {"index", "config", "open", "go", "dir", "-h", "--help"}
    if raw_args and raw_args[0] not in known:
        raw_args = ["go"] + raw_args
    args = parse_args(raw_args)
    try:
        return int(args.func(args))
    except BrokenPipeError:
        try:
            sys.stdout.close()
        finally:
            return 1


if __name__ == "__main__":
    sys.exit(main())


